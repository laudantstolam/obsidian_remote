### Intro

>5 criteric of algorithm

1. Input
2. Output
3. Definition-clear instruction
4. Effectiveness-executabe
5. Finiteness-terminate after some certain steps(we can expect/predict a result)

>procedure / algorithm

- **STOP or not**

> Describing Algorithm

- graph
- Programming Language
- Pseudo code T_T

>SOME FYI in pseudo code

- Loooooop-whiile/for/repeat/.... (in PASCAL)
- "call by value"
- NIL-no object
- Indentation as block structure
- Variables local to the given procedure
- Array-$A[i]/A[1...j]$

---
### Time Complexity

>插入排序法Insertion Sort

[【Day23】[演算法]-插入排序法Insertion Sort - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)](https://ithelp.ithome.com.tw/articles/10277360)

>Devide and conquer

^c681e0

Divide and conquer 基本上分成三個部分，divide、conquer 以及 combine，divide 指的是將整個問題切小，但必須確保問題的題型是一樣的；完成之後再將每個小部分都以==遞迴（recursive)== 的方式處理，這就是 conquer，最後再把每個小部分都結合起來（combine），即是最終答案。 ^23045a

>Merge Sort

拆解成小問題 各自解決後再merge
merge過程: 切半排序後各自會有一個指標在移動，依序比較雙方的值然後排序
時間呈線性
[【Day25】[演算法]-合併排序法Merge Sort - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 (ithome.com.tw)](https://ithelp.ithome.com.tw/articles/10278179)

---
### 字母圈
https://ithelp.ithome.com.tw/articles/10265236?sc=iThelpR

>BIG-Oh $O(n)$

==一個演算法的上界==
![image](https://miro.medium.com/v2/resize:fit:828/format:webp/1*W0rmb-5-CUK9Xobj31Rrfw.png)
>BIG-OMEGA $\Omega$

==一個演算法的下界==

>BIG-THETA

蘊含了$\Omega$和$O$

![image.png|289](https://raw.githubusercontent.com/Ash0645/image_remote/main/202403131657371.png)


>LITTLE-OH

$\lim_{n→∞} \dfrac{g(n)}{f(n)}=0$

==非漸進式的精確上界==

---
### Recurrence

>關於Divide and conquer的時間複雜度

![[#^23045a]]


$$
T(n) = \begin{cases} Θ(1) &\text{if } n=1 \\ 2T(\frac{1}{n})+Θ(n) &\text{if } n>1 \end{cases}
$$
因為分成兩半所以2T

---
(這邊簡報有很多範例)
>歸納法

1. Basis
2. assumption
3. Induction
>替換法

1. 用$n=\frac{n}{2}+b$ 替代
2. 使用相似的解來帶入或是先假定一個較寬鬆的邊界後縮小他

---
> 遞迴樹

- 每個節點代表遞歸發生的子問題的成本
- 每個層級表示一次迭代
- 每個層級有子問題的總成本(橫的相加會是總成本)
- 透過將所有子問題的總成本相加得到總成本

好處: 
- 對於Divide and conquer特別有用
- 正確猜測取代方法 